This is only a test
# -*- coding: utf-8 -*-
"""
Created on Thu Nov 11 15:48:09 2021

@author: aos82
"""


import socket
import tqdm
import os
space = "<space>"
buffer_size = 1024

HOST = '127.0.0.1'  # The server's hostname or IP address
PORT = 65432        # The port used by the server

filename = "GPS_Data.txt"
filesize = os.path.getsize(filename) 
print(int(filesize))

#creates socket object
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT)) #Connects to the server    
s.send(f"{filename}{space}{filesize}".encode())

bar = tqdm.tqdm(range(filesize), f"Sending {filename}", unit="B", unit_scale=True, unit_divisor=512)
with open(filename, "rb") as f:
    while True:
        data = f.read(buffer_size)
        if not data:
            break
        s.sendall(data)
        bar.update(len(data))
s.close()

# -*- coding: utf-8 -*-
"""
Created on Thu Nov 11 13:03:56 2021

@author: aos82
"""

import socket
import tqdm
import os

space = "<space>"
buffer_size = 1024
HOST = '0.0.0.0'  # Standard loopback interface address (localhost) can be a hostname, IP address, or empty string
PORT = 65432        # Port to listen on (non-privileged ports are > 1023) should be an integer from 1-65535 (0 is reserved).

#socket.socket creates a socket object that supports the context manager type
#socket type. AF_INET is the Internet address family for IPv4
#SOCK_STREAM is the socket type for TCP
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((HOST, PORT)) #bind() is used to associate the socket with a specific network interface and port number
s.listen(4) #listen() enables a server to accept() connections
print("listening via", (HOST, PORT))

conn, addr = s.accept() #accept() blocks and waits for an incoming connection
print('Connected by', addr)

recv = conn.recv(buffer_size).decode()
filename, filesize = recv.split(space)
filename = os.path.basename(filename)
filesize = int(filesize)

bar = tqdm.tqdm(range(filesize), f"Receiving {filename}", unit="B", unit_scale=True, unit_divisor=512)
with open(filename, "wb") as f:
    while True: #infinite while loop
        data_read = conn.recv(buffer_size) #reads whatever data the client sends and echoes it back using conn.sendall() (1024 bytes) buffer size
        if not data_read:
            break
        f.write(data_read)
        bar.update(len(data_read))

conn.close()        
s.close()